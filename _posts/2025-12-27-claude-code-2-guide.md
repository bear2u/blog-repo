---
layout: post
title: "Claude Code 2.0 완벽 가이드: 코딩 에이전트 마스터하기"
date: 2025-12-27
author: Sankalp
category: AI
tags: [Claude Code, AI, 코딩 에이전트, Anthropic, Opus 4.5, 컨텍스트 엔지니어링]
original_url: "https://sankalp.bearblog.dev/my-experience-with-claude-code-20-and-how-to-get-better-at-using-coding-agents/"
excerpt: "Claude Code 2.0의 모든 기능과 Opus 4.5 워크플로우, 컨텍스트 엔지니어링 전략까지 - AI 코딩 에이전트를 효과적으로 활용하는 방법에 대한 종합 가이드입니다."
---

이 글은 Sankalp의 Claude Code 2.0 심층 가이드를 번역한 것입니다. 코딩 에이전트를 효과적으로 사용하는 방법, 컨텍스트 엔지니어링, 그리고 실제 워크플로우 전략을 다룹니다.

---

## 저자의 Claude 여정

저자는 2025년 9월, 모델 한계로 인해 Claude Code에서 OpenAI의 Codex로 전환했다가, 11월 Opus 4.5 출시와 함께 다시 돌아왔습니다. 그는 Opus 4.5의 **뛰어난 커뮤니케이션 능력**과 경쟁 모델 대비 **빠른 피드백 루프**를 특히 강조합니다.

| 기간 | 상태 | 이유 |
|------|------|------|
| 2025년 6-9월 | Claude Code 사용 | 초기 채택 |
| 2025년 9-11월 | Codex/GPT-5로 전환 | Sonnet 4/Opus 4 품질 우려 |
| 2025년 11월~ | Claude로 복귀 | Opus 4.5의 압도적 개선 |
| 현재 | Opus 4.5 메인 + GPT-5.2 리뷰용 | 최적의 조합 발견 |

---

## 비기술자를 위한 핵심 개념 설명

### 컨텍스트 (Context)

LLM이 처리하는 입력 토큰들입니다. **컨텍스트 윈도우**는 한 번에 처리할 수 있는 최대 토큰 용량을 의미합니다.

### 도구 호출 (Tool Calling)

LLM이 엔지니어가 정의한 함수를 호출하여 작업을 수행하는 것입니다. 결과는 다시 모델에 피드백됩니다.

### 에이전트 (Agent)

목표 달성을 위해 **능동적으로** 도구를 실행하는 LLM입니다. 작업 완료에 대한 제어권을 유지합니다.

### "에이전틱" (Agentic)

도구 호출의 품질을 설명하는 용어입니다:
- 의도 감지 정확도
- 올바른 도구 선택
- 언제 멈춰야 하는지 아는 것

### 하네스/스캐폴딩 (Harness/Scaffolding)

자율적인 LLM 운영을 가능하게 하는 코드, 프롬프트, 도구 정의, 소프트웨어 패키징 계층들입니다.

---

## Claude Code 2.0 QoL(삶의 질) 개선 사항

### 주요 기능들

1. **구문 강조** (v2.0.71)
   - diff에서 코드 변경사항을 색상으로 구분
   - 변경 내용 파악이 훨씬 쉬워짐

2. **컨텍스트 팁 표시**
   - AI가 생각하는 동안 유용한 팁 제공
   - 대기 시간을 학습 시간으로 활용

3. **우아한 피드백 UI**
   - 작업 흐름을 방해하지 않는 비침입적 인터페이스

4. **Ultrathink 모드**
   - 복잡한 문제에 대한 엄격한 분석
   - `/ultrathink` 명령으로 활성화

5. **`/context` 명령어**
   - 토큰 사용량 모니터링
   - 컨텍스트 상태 실시간 확인

6. **체크포인팅**
   - `Esc + Esc` 또는 `/rewind`로 이전 상태 복원
   - 실험적 변경 후 롤백 가능

7. **프롬프트 제안** (v2.0.73)
   - AI가 다음 프롬프트를 제안
   - 워크플로우 가속화

8. **프롬프트 히스토리 검색**
   - `Ctrl + R`로 이전 프롬프트 검색
   - 반복 작업 효율화

9. **빠른 퍼지 파일 검색**
   - 파일 탐색 속도 대폭 향상

---

## 명령어 시스템 심층 분석

### 정적 명령어

`.claude/commands/` 폴더에 저장되는 정적 프롬프트입니다. 대화에 자동으로 추가됩니다.

### 커스텀 명령어 활용

반복적인 작업을 자동화할 수 있습니다. 저자가 만든 `/handoff` 명령어는 **컨텍스트를 보존하면서 세션을 전환**하는 데 사용됩니다.

```
# 커스텀 명령어 구조 예시
.claude/commands/
├── handoff.md      # 세션 전환
├── review.md       # 코드 리뷰
└── refactor.md     # 리팩토링
```

### 명령어 작성 팁

- 명확하고 구체적인 지시 작성
- 원하는 출력 형식 명시
- 컨텍스트에 추가될 내용 고려

---

## 서브 에이전트 완전 정복

서브 에이전트는 **Task 도구**를 통해 생성되는 별도의 Claude 인스턴스입니다.

### 5가지 서브 에이전트 유형

| 유형 | 역할 | 특징 |
|------|------|------|
| **General-purpose** | 범용 작업 | 전체 컨텍스트 상속, 모든 도구 접근 |
| **Explore** | 코드베이스 검색 | 읽기 전용, 새 컨텍스트로 시작 |
| **Plan** | 아키텍처 설계 | 전체 컨텍스트 상속, 설계 특화 |
| **claude-code-guide** | 문서 조회 | 문서화 특화 |
| **statusline-setup** | 설정 관리 | 설정 특화 |

### Explore 에이전트 상세

Explore 에이전트는 **glob/grep/read 명령만** 사용할 수 있으며 파일 수정 기능이 없습니다:

```
Explore 에이전트 특성:
├── 읽기 전용 (파일 수정 불가)
├── glob - 파일 패턴 검색
├── grep - 내용 검색
├── read - 파일 읽기
└── 새로운 컨텍스트에서 시작
```

### 컨텍스트 상속 규칙

**중요한 차이점:**

- **General-purpose, Plan**: 전체 컨텍스트 상속
- **Explore**: 새로운 컨텍스트에서 시작 (불필요한 정보 차단)

이 설계는 **Explore 에이전트가 관련 없는 정보로 부풀어오르는 것을 방지**합니다.

### Task 도구 파라미터

| 파라미터 | 설명 | 필수 |
|----------|------|------|
| `description` | 3-5 단어 설명 | ✅ |
| `prompt` | 상세 작업 내용 | ✅ |
| `subagent_type` | 에이전트 유형 | ✅ |
| `model` | Sonnet/Opus/Haiku | ❌ |
| `resume` | 이전 작업 재개 | ❌ |
| `background` | 백그라운드 실행 | ❌ |

---

## 컨텍스트 엔지니어링 핵심 전략

### 컨텍스트 윈도우 역학

도구 호출과 그 결과 **모두** 토큰을 소비합니다. 단일 작업 완료에도 검색, 파일 읽기, 편집을 통해 **6,000+ 토큰**이 쉽게 소비될 수 있습니다.

### 컨텍스트 열화 (Context Degradation)

컨텍스트가 커질수록 LLM 효과가 감소합니다 - **어텐션 예산이 압박**받기 때문입니다.

```
⚠️ 중요한 사실:
├── 효과적인 컨텍스트 윈도우 = 이론적 최대치의 50-60%
├── 200K 토큰 윈도우 → 실제 효과적 사용 100-120K
└── "Lost in the middle" 현상 발생
```

### 컨텍스트 관리 기법

1. **반복 시스템 리마인더**
   - 대화에 주기적으로 주입
   - 목표를 상기시킴

2. **Todo 리스트 반복**
   - 실행 전반에 걸쳐 목표 재확인
   - 집중력 유지

3. **압축 (Compaction)**
   - `/compact` 명령으로 불필요한 컨텍스트 정리
   - 60% 용량 도달 시 사용 권장

4. **서브 에이전트 활용**
   - 병렬 특화 작업
   - 메인 컨텍스트 부풀림 방지

### 실용적 팁

> **코드베이스 검색에는 Explore 에이전트 사용** - 메인 컨텍스트 부풀림 방지

> **관련 파일은 메인 에이전트가 직접 다시 읽도록** - 컨텍스트 조각들 간 크로스 어텐션 가능

> **대화 중간에 복잡한 작업 시작 금지** - 대신 압축 후 시작

---

## 시스템 리마인더와 아키텍처

### 시스템 리마인더 태그

`<system-reminder>` 태그는 사용자 메시지와 도구 결과에 나타납니다. 이는 긴 컨텍스트에서 **"중간에서 길을 잃는" 문제**를 해결합니다.

```
시스템 리마인더 역할:
├── 모델이 초기 목표를 잊지 않도록
├── 중요한 지시사항 반복
└── 컨텍스트 전반에 걸쳐 일관성 유지
```

### Plan Mode 아키텍처

Plan Mode는 특화된 도구 스키마를 사용합니다:
- `ENTRY_PLAN_MODE_TOOL` - 플래닝 모드 진입
- `EXIT_PLAN_MODE_TOOL` - 플래닝 모드 종료

계획은 `/plan` 명령으로 접근 가능한 **마크다운 파일로 저장**됩니다.

---

## 스킬, 플러그인, 훅

### 스킬 (Skills)

SKILL.md 메타데이터와 코드 스크립트가 포함된 폴더입니다.

**특징:**
- Claude가 **온디맨드로 로드**
- 시스템 프롬프트를 가볍게 유지
- **권장 최대 크기: 스킬 파일당 500줄**

```
skills/
├── frontend-design/
│   ├── SKILL.md
│   └── guidelines.md
└── api-design/
    ├── SKILL.md
    └── patterns.md
```

### 플러그인 (Plugins)

번들된 스킬, 명령어, 서브 에이전트, 훅, MCP 서버를 **네임스페이싱과 함께 배포**합니다.

```bash
# 플러그인 명령어 예시
/my-plugin:hello
/frontend:review
```

### 훅 (Hooks)

에이전트 생명주기 단계를 관찰하고 **bash 스크립트를 실행**합니다.

| 훅 | 실행 시점 | 활용 예시 |
|----|----------|----------|
| `Stop` | 응답 완료 후 | 알림 발송 |
| `UserPromptSubmit` | 처리 전 | 입력 검증 |
| `PreToolUse` | 도구 사용 전 | 권한 확인 |
| `PostToolUse` | 도구 사용 후 | 결과 로깅 |

**활용 패턴:** 훅을 통해 연속 작업을 트리거하거나 알림을 발송할 수 있습니다.

### 통합 패턴

훅과 스킬을 결합하여 **CLAUDE.md를 가볍게 유지**하면서 지시를 스킬 파일로 분리합니다. 훅은 모델에게 스킬 가용성을 알려줍니다.

---

## MCP 서버와 코드 실행

### MCP 서버

도구, 리소스, 통합을 노출하지만 **도구 정의를 미리 로드하여 컨텍스트를 부풀립니다**.

```
⚠️ MCP 주의사항:
├── 여러 MCP 서버 = 컨텍스트 소비 증가
├── 지연 시간 증가
└── 신중한 선택 필요
```

### MCP를 활용한 코드 실행

직접 도구 호출 대신 **코드 API를 노출**하는 것이 권장됩니다. Claude가 샌드박스 환경에서 코드를 작성하게 합니다.

---

## 저자의 실제 워크플로우 전략

### 4단계 접근법

#### 1단계: 탐색 (Exploration)
```
목표: 요구사항 이해
├── Opus 4.5에게 명확화 질문
├── 요구사항의 모호한 부분 파악
└── 범위 정의
```

#### 2단계: 계획 (Planning)
```
목표: 엄격한 분석
├── /ultrathink 사용
├── 아키텍처 결정
└── 위험 요소 식별
```

#### 3단계: 실행 (Execution)
```
목표: 구현
├── 변경사항 면밀히 모니터링 (마이크로 매니지)
├── 문제 발생 시 즉시 개입
└── "버릴 첫 번째 초안" 접근법
```

#### 4단계: 리뷰 (Review)
```
목표: 버그 탐지
├── GPT-5.2-Codex의 /review 사용
├── 심각도 수준 확인 (P1, P2)
└── 오탐 최소화
```

### 파일 관리

저자는 다음 파일들을 유지합니다:
- **CLAUDE.md** - 프로젝트 컨텍스트
- **scratchpad 파일** - 임시 메모
- **MCP 서버** - 필요시 사용
- **백그라운드 에이전트** - 관찰 가능성 확보

### "버릴 첫 번째 초안" 접근법

> 초기 기능 구현 시 **마이크로 매니지**하면서 "버릴 첫 번째 초안" 접근법을 사용합니다. 이를 통해 **모델의 의사결정 과정을 이해**할 수 있습니다.

---

## 모델 비교: Opus 4.5 vs GPT-5.2-Codex

### 직접 비교

| 항목 | Opus 4.5 | GPT-5.2-Codex |
|------|----------|---------------|
| **처리량** | 더 빠름 | 보통 |
| **커뮤니케이션** | 탁월함 | 간결함 |
| **의도 감지** | 우수 | 보통 |
| **개성** | "협력적" | 사무적 |
| **원시 능력** | 우수 | 약간 우위 |
| **버그 탐지** | 보통 | 탁월함 |
| **출력 스타일** | 상세함 | 간결함 |

### 컨텍스트 윈도우 비교

| 모델 | 컨텍스트 윈도우 |
|------|----------------|
| Opus 4.5 | 200K 토큰 |
| GPT-5.2 | 400K 토큰 |
| Gemini 3 Pro | 1M 토큰 |

### 최적의 조합

저자의 결론:
- **구현**: Opus 4.5 (빠른 피드백, 뛰어난 커뮤니케이션)
- **코드 리뷰**: GPT-5.2-Codex (버그 탐지 우수)

> "Opus 4.5는 단순한 도구가 아니라 **진정한 페어 프로그래밍 파트너**입니다."

---

## 실용적 팁 모음

### 컨텍스트 관리

1. **Explore 에이전트로 코드베이스 검색** - 메인 컨텍스트 부풀림 방지
2. **관련 파일은 메인 에이전트가 직접 읽도록** - 크로스 어텐션 활성화
3. **대화 중간에 복잡한 작업 시작 금지** - 압축 후 시작

### 워크플로우

4. **"버릴 첫 번째 초안"으로 모델 이해** - 의사결정 과정 학습
5. **구현은 Claude, 리뷰는 GPT** - 각 모델의 강점 활용
6. **마이크로 매니지 초기 구현** - 문제 조기 발견

### 도구 활용

7. **스킬 파일 500줄 이하 유지** - 로딩 효율성
8. **훅으로 반복 작업 자동화** - 워크플로우 가속
9. **MCP 서버 신중히 선택** - 컨텍스트 비용 고려

---

## 미래 전망

저자는 다음 개선을 예상합니다:

- **강화학습 훈련** 향상
- **새로운 어텐션 메커니즘**을 통한 긴 컨텍스트 효과 개선
- **더 높은 처리량** 모델
- **환각 감소**
- DeepSeek, Kimi K3 모델 기대

---

## 핵심 메시지

### 7가지 교훈

1. **도구 숙련도 전이** - Claude Code 학습이 다른 에이전트 플랫폼에도 적용됨

2. **컨텍스트가 핵심** - 컨텍스트 엔지니어링 이해가 효과를 근본적으로 향상

3. **증강 마인드셋** - "따라잡기"보다 기존 스킬을 증폭하는 도구 사용에 집중

4. **실험이 중요** - 기능을 정기적으로 시도하고 직관 개발

5. **커스터마이징 파워** - 스킬, 훅, 명령어로 개인화 워크플로우 구축

6. **모델 선택** - 작업에 맞는 모델 선택 (Opus=구현, GPT=리뷰)

7. **빠른 피드백 루프** - 처리량이 원시 능력만큼 중요

### 저자의 결론

> "구현 속도가 빨라진 만큼, 개발자들은 **취향 다듬기**, **시스템 설계 사고**, 그리고 LLM을 **증강 파트너로 활용**하는 데 집중해야 합니다."

릴리스를 "따라잡으려고" 경쟁하는 것이 아니라, **AI를 활용해 자신의 역량을 증폭**시키는 것이 핵심입니다.

---

## 마치며

> **"오늘 이 글에서 새로운 기능 하나를 시도해보세요."**

저자가 강조하는 세 가지:
- ✅ **도구 최신화 유지**
- ✅ **도메인 업스킬**
- ✅ **실험을 통한 열린 마음 유지**

---

*이 글은 [Sankalp의 원문](https://sankalp.bearblog.dev/my-experience-with-claude-code-20-and-how-to-get-better-at-using-coding-agents/)을 한국어로 번역 및 정리한 것입니다.*
