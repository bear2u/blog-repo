---
layout: post
title: "Claude Code 2.0 가이드 (10) - MCP와 시스템 리마인더"
date: 2025-12-28
permalink: /claude-code-2-guide-10-mcp-reminders/
author: Sankalp
categories: [AI 코딩 에이전트, Claude Code]
tags: [Claude Code, AI, MCP, 시스템 리마인더, Plan Mode]
original_url: "https://sankalp.bearblog.dev/my-experience-with-claude-code-20-and-how-to-get-better-at-using-coding-agents/"
excerpt: "MCP 서버와 코드 실행, 시스템 리마인더가 어떻게 컨텍스트 열화에 대응하는지, Plan Mode의 아키텍처를 살펴봅니다."
---

## MCP 서버와 코드 실행

MCP 서버는 제 주력 도구는 아니지만, 다룰 가치가 있습니다.

### MCP 서버란?

MCP 서버는 **로컬 머신이나 인터넷에서 원격으로 호스팅**될 수 있는 서버입니다. 파일시스템, 도구, CRM, Google Drive 같은 통합을 노출할 수 있습니다. 본질적으로 **모델이 외부 도구와 서비스에 연결하는 방법**입니다.

### MCP 연결 방식

MCP 서버에 연결하려면, MCP 클라이언트를 수용할 수 있는 **호스트(Claude)**가 필요합니다. MCP 클라이언트는 연결하기 위해 프로토콜을 호출할 수 있습니다. 연결되면, MCP 클라이언트는 서버가 제공하는 **도구, 리소스, 프롬프트를 노출**합니다.

```
┌──────────────────────────────────────────┐
│                 Claude (호스트)           │
│  ┌──────────────────────────────────┐   │
│  │          MCP 클라이언트           │   │
│  │  ┌─────────────────────────────┐ │   │
│  │  │      MCP 프로토콜 호출       │ │   │
│  │  └─────────────────────────────┘ │   │
│  └──────────────────────────────────┘   │
└──────────────────────────────────────────┘
           │
           ▼
┌──────────────────────────────────────────┐
│              MCP 서버                     │
│  ├── 도구 (Tools)                        │
│  ├── 리소스 (Resources)                  │
│  └── 프롬프트 (Prompts)                  │
└──────────────────────────────────────────┘
```

**중요:** 도구 정의가 **미리 컨텍스트 윈도우에 로드**되어 부풀립니다.

---

## MCP를 활용한 코드 실행

저는 토큰 소비 증가를 위한 프로파간다임에도 불구하고 **MCP를 활용한 코드 실행 아이디어**가 좋습니다.

[Code execution with MCP](https://www.anthropic.com/research/code-execution-with-mcp)에서 인용:

> MCP 사용량이 증가함에 따라, 에이전트 비용과 지연을 증가시킬 수 있는 두 가지 일반적인 패턴이 있습니다:
>
> 1. 도구 정의가 컨텍스트 윈도우를 과부하시킴
> 2. 중간 도구 결과가 추가 토큰을 소비함

**더 많은 MCP 서버 = 컨텍스트를 부풀리는 더 많은 도구 정의**

### 해결책: 코드 API 노출

MCP Code exec는 직접적인 도구 호출 대신 **도구 호출 정의가 아닌 코드 API를 노출**하고 Claude에게 **파일시스템이 있는 샌드박스 실행 환경**을 주는 것을 제안합니다. 그러면 Claude가 도구 호출을 하는 코드를 작성하게 합니다.

이는 **스킬과 비슷한 "온디맨드 프롬프트"**라는 점에서 우아한 아이디어입니다.

---

## Claude 프롬프트의 시스템 리마인더란

컨텍스트 열화에 대응하는 한 가지 기술은 **목표를 컨텍스트에 반복적으로 주입**하는 것입니다.

### Manus의 접근법

Manus는 [Context Engineering](https://blog.manus.app/posts/context-engineering-for-ai-agents) 블로그에서 그들의 접근법을 공유했습니다:

> **낭독을 통한 어텐션 조작**
>
> Manus를 사용해보셨다면, 뭔가 흥미로운 것을 눈치채셨을 것입니다: 복잡한 작업을 처리할 때, todo.md 파일을 만드는 경향이 있습니다 - 그리고 작업이 진행됨에 따라 단계별로 업데이트하며, 완료된 항목을 체크합니다.
>
> 그것은 단순히 귀여운 행동이 아닙니다 - **어텐션을 조작하기 위한 의도적인 메커니즘**입니다.
>
> Manus의 일반적인 작업은 평균 약 50개의 도구 호출이 필요합니다. 그것은 긴 루프입니다 - 그리고 Manus가 의사 결정에 LLM에 의존하기 때문에, 특히 긴 컨텍스트나 복잡한 작업에서 주제에서 벗어나거나 이전 목표를 잊는 데 취약합니다.
>
> todo 리스트를 지속적으로 다시 작성함으로써, Manus는 **목표를 컨텍스트 끝으로 낭독**하고 있습니다. 이것은 전역 계획을 모델의 최근 어텐션 범위로 밀어넣어, "중간에서 길을 잃는" 문제를 피하고 목표 불일치를 줄입니다. 사실상, 특별한 아키텍처 변경 없이 **자연어를 사용하여 자신의 초점을 작업 목표로 편향**시키고 있습니다.

---

## Claude Code의 Todo 리스트

Claude Code에도 todo 리스트가 있습니다. 이제 그 로직의 일부를 알게 되었습니다. **리마인더 역할**을 합니다. todo 리스트와 계획 모두 마크다운 파일로 저장되고 **압축 중에 보존**됩니다. 따라서 상태를 보존하는 데도 사용됩니다.

---

## 시스템 리마인더 태그

Claude Code는 **사용자 메시지와 도구 결과에 리마인더 태그를 연결**하는 것과 비슷한 것을 시도합니다. 일부는 도구 설명에 언급되어 있고, 다른 리마인더는 코드를 통해 런타임에 추가됩니다.

Claude에게 시스템 프롬프트에 어떤 시스템 리마인더가 있는지 물어봤습니다:

```
> 나에게: 프롬프트에 어떤 시스템 리마인더가 있는지 알려줘.
정확한 것을 보여줘. 태그도 보여줘.
어디에 추가되는지 알려줘. 내 CLAUDE MD는 편집해.
ultrathink 간결한 출력 부탁해

⏺ 제가 볼 수 있는 것:

  시스템 리마인더 위치

  1. 사용자 메시지에서 (방금 보낸 것처럼):
  <system-reminder>
  사용자의 질문에 답할 때, 다음 컨텍스트를 사용할 수 있습니다:
  # claudeMd
  코드베이스와 사용자 지시가 아래에 표시됩니다...

  /Users/sankalp/.claude/CLAUDE.md의 내용 (모든 프로젝트에 대한 사용자의 개인 전역 지시):
  [편집됨 - 개인 CLAUDE.md]
  </system-reminder>

  2. 내 지시에서 참조됨:
  "도구 결과와 사용자 메시지는 <system-reminder> 태그를 포함할 수 있습니다.
  <system-reminder> 태그는 유용한 정보와 리마인더를 포함합니다.
  시스템에 의해 자동으로 추가되며, 나타나는 특정 도구 결과나
  사용자 메시지와 직접적인 관련이 없습니다."
```

참고로, CC 2.0.56의 이전 버전에는 이런 상세한 리마인더 system-reminder-plan-mode-is-active가 있었습니다.

---

## Plan Mode 아키텍처

Armin이 [What Actually Is Claude Code's Plan Mode?](https://mitsuhiko.com/p/what-actually-is-claude-codes-plan-mode/) 포스트에서 에이전트에게 상기시키기 위한 반복 프롬프트를 언급할 때 이것에 대해 이야기한다고 생각합니다.

유출된 프롬프트를 보면, Plan Mode에 대한 2-3개의 프롬프트와 `ENTRY_PLAN_MODE_TOOL`, `EXIT_PLAN_MODE_TOOL` 같은 2-3개의 도구 스키마가 있는 것을 알 수 있습니다. 후자는 `/plan`을 통해 접근할 수 있는 마크다운 파일에 출력을 기록합니다.

> **모든 것이 마크다운입니다.**

---

*다음 글에서는 스킬, 플러그인, 훅에 대해 알아봅니다.*
