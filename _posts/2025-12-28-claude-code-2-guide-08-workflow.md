---
layout: post
title: "Claude Code 2.0 가이드 (8) - 나의 워크플로우"
date: 2025-12-28
permalink: /claude-code-2-guide-08-workflow/
author: Sankalp
categories: [AI 코딩 에이전트, Claude Code]
tags: [Claude Code, AI, 워크플로우, 개발 프로세스, 코드 리뷰]
original_url: "https://sankalp.bearblog.dev/my-experience-with-claude-code-20-and-how-to-get-better-at-using-coding-agents/"
excerpt: "저자의 실제 Claude Code 워크플로우를 공유합니다. 탐색, 실행, 리뷰까지 실용적인 전략들을 소개합니다."
---

## 나의 워크플로우

### 셋업

저는 꽤 간단한/작업 기반 워크플로우를 가지고 있습니다:

| 도구 | 용도 |
|------|------|
| **Claude Code** | 메인 드라이버 |
| **Codex** | 리뷰와 어려운 작업 |
| **Cursor** | 코드 읽기와 수동 편집 |

Plan Mode는 거의 사용하지 않습니다. 대신, 요구사항이 충분히 명확해지면 관련 파일을 직접 찾아서 코드베이스를 탐색합니다.

**편집:** Plan Mode를 조금 더 사용해보기 시작했지만, 여전히 현재 접근 방식을 선호합니다.

---

## 탐색과 실행 (Exploration and Execution)

Opus 4.5는 설명을 정말 잘하고 멋진 ASCII 다이어그램을 만듭니다. 2025년 5월 지식 컷오프도 여기서 도움이 됩니다. 그래서 제 탐색은 **많은 질문을 하는 것**을 포함합니다 - 요구사항 명확화, 어디서/어떻게/왜 변경해야 하는지 이해. Plan Mode보다 덜 효율적일 수 있지만, 이 접근 방식이 좋습니다.

```
탐색 단계:
├── 요구사항 명확화 질문
├── 변경이 필요한 위치 파악
├── 변경 방법 이해
└── 변경 이유 파악
```

### 실행 단계

충분한 컨텍스트가 있으면, `/ultrathink`를 자주 사용하고 어떤 변경이 필요한지 물어봅니다. 그리고 괜찮아 보이면, 변경을 면밀히 모니터링하면서 실행을 시작합니다 - **기본적으로 마이크로 매니징**합니다. 때때로 여기서 Codex의 세컨드 오피니언을 물어봅니다 ㅋㅋ.

---

## "버릴 첫 번째 초안" 접근법

어려운 새 기능의 경우, 때때로 **"버릴 첫 번째 초안"** 접근법을 사용합니다:

1. 어떤 변경이 필요한지 이해하면, 새 브랜치를 만듭니다
2. Claude가 관찰하는 동안 기능을 처음부터 끝까지 작성하게 합니다
3. 그 출력을 제 멘탈 모델과 비교합니다
   - 제 요구사항에 얼마나 가까웠나?
   - 어디서 벗어났나?

이 과정은 Claude의 오류와 가진 컨텍스트에 기반한 결정/편향을 드러냅니다. 이 후향적 이점으로, 첫 번째 패스에서 배운 것을 바탕으로 **더 날카로운 프롬프트**로 다른 이터레이션을 실행합니다.

> Tenet 영화처럼요.

---

## 복잡한 기능의 경우

백엔드 중심이거나 복잡한 기능의 경우, 때때로 **Codex xhigh에게 계획을 생성**하도록 요청합니다.

---

## 사용하는 것 (그리고 사용하지 않는 것)

| 사용함 | 사용 안 함 / 드물게 |
|--------|-------------------|
| 몇 가지 커스텀 명령어 | 커스텀 서브 에이전트 |
| CLAUDE.md 광범위하게 | MCP (필요시에만) |
| 스크래치패드 광범위하게 | 스킬/플러그인 (더 자주 사용 예정) |
| 관찰 가능성용 백그라운드 에이전트 | git worktrees |

MCP는 때때로 필요시 사용합니다(예: 문서용. Playwright와 Figma MCP를 시도해봤습니다) 하지만 일반적으로 팬은 아닙니다. 훅은 과거에 간단한 것과 필요 기반으로 사용했습니다. 스킬/플러그인은 아직 더 정기적으로 사용해야 합니다. 관찰 가능성(로그/오류 모니터링) 목적으로 백그라운드 에이전트를 자주 사용합니다. git worktrees는 거의 사용하지 않습니다.

---

## 하네스의 힘

**하네스가 너무 많이 엔지니어링되어 있어서** Claude는 어떤 서브 에이전트를 생성할지, 어떤 명령어/도구 호출/스킬을 실행할지, 무엇을 비동기 방식으로 실행할지 알고 있습니다. 에이전트 루프를 많이 담당할 수 있어서 **여러분의 작업은 주로 판단력을 사용하고 올바른 방향으로 프롬프트하는 것**입니다.

> 다음 세대의 모델들은 더 나아질 것이고, 기존 기능에 대한 관련 스캐폴딩은 줄어들고 새로운 기능에 대해서는 늘어날 것입니다. (참고: 처음에 보여준 Karpathy 선생님의 최신 트윗과 대조)

솔직히 기능을 깊이 알 필요는 전혀 없습니다. 하지만 **작동 방식을 알면 모델을 더 잘 조종**할 수 있습니다 - Explore 에이전트에게 Sonnet을 사용하라고 말하는 것처럼요.

---

## 리뷰 (Review)

**코드를 리뷰하고 버그를 찾는 데는 GPT-5.2-Codex가 우월합니다.** `/review`만 사용하면 됩니다. 코드 리뷰 제품들보다 낫습니다.

```
GPT-5.2-Codex /review 특성:
├── 버그 찾기 및 심각도 언급 (P1, P2)
├── 오탐(false-positive) 가능성 낮음
├── 혼란스러운 변경에 대해 더 신뢰할 수 있음
└── Claude보다 리뷰/버그에서 우수
```

**실행에는 Claude, 리뷰/버그에는 GPT/o-시리즈 모델** - 이 역동 관계는 아마 1년 동안 꽤 일정했습니다.

---

*다음 글에서는 컨텍스트 엔지니어링에 대해 심층적으로 다룹니다.*
