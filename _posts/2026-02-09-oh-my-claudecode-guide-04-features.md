---
layout: post
title: "oh-my-claudecode 완벽 가이드 (04) - 핵심 기능 및 도구"
date: 2026-02-09
permalink: /oh-my-claudecode-guide-04-features/
author: Yeachan Heo
categories: [AI 코딩, CLI]
tags: [Claude Code, Multi-Agent, Orchestration, AI, CLI, Autopilot, Ultrawork]
original_url: "https://github.com/Yeachan-Heo/oh-my-claudecode"
excerpt: "32개 전문 에이전트, 스마트 모델 라우팅, HUD 상태 표시줄, 스킬 학습 시스템, 분석 및 비용 추적 등 oh-my-claudecode의 핵심 기능을 상세히 알아봅니다."
---

## 32개 전문 에이전트 상세

oh-my-claudecode의 핵심은 **32개의 전문화된 에이전트**입니다. 각 에이전트는 특정 도메인에 최적화되어 있으며, 오케스트레이터가 작업의 성격을 분석하여 가장 적합한 에이전트를 자동으로 선택합니다.

### Architecture 에이전트 (4개)

시스템 설계와 구조적 결정을 담당하는 에이전트들입니다.

#### 1. arch (Architect)

전체 시스템 아키텍처를 설계합니다.

**전문 분야:**
- 마이크로서비스 아키텍처 설계
- 모놀리식 vs 분산 시스템 결정
- 데이터 플로우 설계
- 시스템 간 통신 프로토콜 선택

**사용 예시:**
```bash
> arch: design a microservices architecture for an e-commerce platform
```

**에이전트 출력:**
```
Architecture Proposal:
┌──────────────────────────────────────────────┐
│ API Gateway (Kong/Nginx)                     │
├──────────────────────────────────────────────┤
│ ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐│
│ │ Auth   │ │Product │ │Payment │ │Order   ││
│ │Service │ │Service │ │Service │ │Service ││
│ └────────┘ └────────┘ └────────┘ └────────┘│
├──────────────────────────────────────────────┤
│ Message Queue (RabbitMQ/Kafka)               │
├──────────────────────────────────────────────┤
│ ┌──────────┐ ┌──────────┐                   │
│ │PostgreSQL│ │  Redis   │                   │
│ └──────────┘ └──────────┘                   │
└──────────────────────────────────────────────┘
```

#### 2. ralph (Reliable Architecture Long-term Planning)

장기적인 아키텍처 계획과 진화 전략을 수립합니다.

**전문 분야:**
- 확장성 계획
- 기술 부채 관리 전략
- 마이그레이션 로드맵
- 레거시 시스템 현대화

**사용 예시:**
```bash
> ralph: plan migration from monolith to microservices over 6 months
```

**특징:**
- 단계별 마이그레이션 계획 생성
- 리스크 분석 및 완화 전략
- 롤백 계획 포함
- 100% 완료될 때까지 실행 (오류 자동 복구)

#### 3. ralplan (Ralph + Planning)

Ralph의 계획 능력에 집중한 모드입니다.

**전문 분야:**
- 상세 작업 분해 (WBS)
- 의존성 매핑
- 리소스 할당
- 타임라인 추정

**사용 예시:**
```bash
> ralplan: create detailed plan for implementing real-time chat feature
```

**출력 형식:**
```
Phase 1: Infrastructure Setup (2 days)
├─ [1.1] WebSocket server setup
├─ [1.2] Redis pub/sub configuration
└─ [1.3] Load balancer configuration

Phase 2: Backend Implementation (3 days)
├─ [2.1] Message persistence layer
├─ [2.2] Room management API
└─ [2.3] User presence tracking

Phase 3: Frontend Integration (2 days)
├─ [3.1] WebSocket client
├─ [3.2] UI components
└─ [3.3] State management

Phase 4: Testing & Deployment (2 days)
├─ [4.1] Unit tests
├─ [4.2] Integration tests
└─ [4.3] Load testing
```

#### 4. system-architect

시스템 레벨 기술 결정을 담당합니다.

**전문 분야:**
- 기술 스택 선택
- 인프라 아키텍처
- 보안 아키텍처
- 데이터 아키텍처

**사용 예시:**
```bash
> system-architect: recommend tech stack for real-time collaboration tool
```

### Research 에이전트 (3개)

정보 수집, 분석, 조사를 전문으로 합니다.

#### 1. deepsearch

깊이 있는 기술 조사를 수행합니다.

**전문 분야:**
- 라이브러리 비교 분석
- 베스트 프랙티스 조사
- 기술 트렌드 분석
- 문제 해결 방법 탐색

**사용 예시:**
```bash
> deepsearch: compare React state management libraries (Redux vs Zustand vs Jotai)
```

**분석 형식:**
```
Library Comparison Matrix:

┌──────────┬─────────┬──────────┬───────┬────────────┐
│          │ Bundle  │ Learning │Boiler │Performance │
│          │ Size    │ Curve    │plate  │ Score      │
├──────────┼─────────┼──────────┼───────┼────────────┤
│Redux     │ 7.5 KB  │ High     │ High  │ 85/100     │
│Zustand   │ 1.2 KB  │ Low      │ Low   │ 92/100     │
│Jotai     │ 2.9 KB  │ Medium   │ Medium│ 90/100     │
└──────────┴─────────┴──────────┴───────┴────────────┘

Recommendation: Zustand
Reason: Best balance of simplicity and performance
```

#### 2. researcher

프로젝트 관련 연구를 수행합니다.

**전문 분야:**
- 코드베이스 분석
- 의존성 조사
- API 문서 탐색
- 예제 코드 수집

**사용 예시:**
```bash
> researcher: analyze the current authentication implementation and suggest improvements
```

#### 3. doc-analyzer

문서를 분석하고 인사이트를 추출합니다.

**전문 분야:**
- API 문서 파싱
- README 분석
- 코드 주석 해석
- 설계 문서 리뷰

**사용 예시:**
```bash
> doc-analyzer: extract all API endpoints from the OpenAPI spec
```

### Design 에이전트 (3개)

UI/UX 및 인터페이스 디자인을 담당합니다.

#### 1. designer

전반적인 디자인 작업을 수행합니다.

**전문 분야:**
- 컴포넌트 디자인
- 레이아웃 설계
- 색상 팔레트 선택
- 타이포그래피

**사용 예시:**
```bash
> designer: create a modern dashboard layout with sidebar navigation
```

**출력 예시:**
```jsx
// Generated by Designer Agent
const Dashboard = () => {
  return (
    <div className="flex h-screen bg-gray-50">
      {/* Sidebar */}
      <aside className="w-64 bg-white shadow-lg">
        <nav className="p-4 space-y-2">
          <NavItem icon={HomeIcon} label="Dashboard" />
          <NavItem icon={UsersIcon} label="Users" />
          <NavItem icon={SettingsIcon} label="Settings" />
        </nav>
      </aside>

      {/* Main Content */}
      <main className="flex-1 p-8 overflow-auto">
        <header className="mb-8">
          <h1 className="text-3xl font-bold">Dashboard</h1>
        </header>
        <div className="grid grid-cols-3 gap-6">
          <MetricCard title="Total Users" value="1,234" />
          <MetricCard title="Revenue" value="$45,678" />
          <MetricCard title="Conversion" value="3.2%" />
        </div>
      </main>
    </div>
  );
};
```

#### 2. ux-specialist

사용자 경험 최적화를 담당합니다.

**전문 분야:**
- 사용성 개선
- 접근성 (a11y)
- 인터랙션 디자인
- 사용자 플로우 최적화

**사용 예시:**
```bash
> ux-specialist: improve the checkout flow to reduce cart abandonment
```

**개선 제안:**
```
Current Flow Issues:
1. Too many steps (5 steps)
2. Shipping info requested twice
3. No progress indicator
4. Mobile experience poor

Optimized Flow:
Step 1: Cart Review + Guest/Login option
Step 2: Combined Shipping & Billing
Step 3: Payment (with saved methods)
Step 4: Confirmation

Improvements:
✓ Reduced to 4 steps (-20%)
✓ Progress bar added
✓ Auto-fill from profile
✓ Mobile-first design
✓ Expected reduction in abandonment: 25-30%
```

#### 3. design-validator

디자인 일관성과 품질을 검증합니다.

**전문 분야:**
- 디자인 시스템 준수 검증
- 색상 대비 검사 (WCAG)
- 반응형 디자인 검증
- 브랜드 가이드라인 준수

**사용 예시:**
```bash
> design-validator: check if all components follow the design system
```

### Testing 에이전트 (4개)

품질 보증과 테스팅을 전담합니다.

#### 1. tdd (Test-Driven Development)

TDD 방식으로 개발을 진행합니다.

**작업 순서:**
1. 테스트 작성 (Red)
2. 최소 구현 (Green)
3. 리팩토링 (Refactor)

**사용 예시:**
```bash
> tdd: implement user authentication with TDD approach
```

**생성 코드:**
```javascript
// Step 1: Write failing test
describe('Authentication', () => {
  it('should hash password before saving', async () => {
    const user = { email: 'test@example.com', password: 'plain' };
    const saved = await createUser(user);
    expect(saved.password).not.toBe('plain');
    expect(saved.password).toMatch(/^\$2[aby]\$/);
  });
});

// Step 2: Minimal implementation
const createUser = async (userData) => {
  const hashedPassword = await bcrypt.hash(userData.password, 10);
  return db.users.create({
    ...userData,
    password: hashedPassword
  });
};

// Step 3: Refactor (if needed)
```

#### 2. ultraqa

종합적인 품질 보증을 수행합니다.

**전문 분야:**
- 다층 테스트 (Unit, Integration, E2E)
- 성능 테스트
- 보안 테스트
- 회귀 테스트

**사용 예시:**
```bash
> ultraqa: create comprehensive test suite for the API
```

**테스트 커버리지:**
```
Test Suite Results:
├─ Unit Tests: 234 tests, 98.5% coverage
├─ Integration Tests: 45 tests, 92.3% coverage
├─ E2E Tests: 12 scenarios, 100% critical paths
├─ Performance: API response < 200ms ✓
├─ Security: 0 vulnerabilities ✓
└─ Load Test: 1000 concurrent users ✓

Overall Quality Score: 96/100
```

#### 3. e2e-tester

End-to-End 테스트를 전문으로 합니다.

**전문 분야:**
- Playwright/Cypress 테스트
- 사용자 시나리오 테스트
- 브라우저 호환성 테스트
- 비주얼 회귀 테스트

**사용 예시:**
```bash
> e2e-tester: create E2E tests for the checkout flow
```

**생성된 테스트:**
```typescript
// tests/e2e/checkout.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Checkout Flow', () => {
  test('should complete purchase as guest user', async ({ page }) => {
    // Add product to cart
    await page.goto('/products/123');
    await page.click('[data-testid="add-to-cart"]');

    // Go to checkout
    await page.click('[data-testid="cart-icon"]');
    await page.click('[data-testid="checkout-button"]');

    // Fill shipping info
    await page.fill('[name="email"]', 'guest@example.com');
    await page.fill('[name="address"]', '123 Main St');
    await page.click('[data-testid="continue-to-payment"]');

    // Complete payment
    await page.fill('[name="cardNumber"]', '4242424242424242');
    await page.fill('[name="expiry"]', '12/25');
    await page.fill('[name="cvc"]', '123');
    await page.click('[data-testid="complete-order"]');

    // Verify confirmation
    await expect(page.locator('[data-testid="order-confirmation"]'))
      .toBeVisible();
    await expect(page.locator('[data-testid="order-number"]'))
      .toHaveText(/^ORDER-\d+$/);
  });
});
```

#### 4. security-auditor

보안 취약점을 검사하고 수정합니다.

**전문 분야:**
- OWASP Top 10 검사
- SQL 인젝션 방어
- XSS 방어
- CSRF 방어
- 인증/인가 검증

**사용 예시:**
```bash
> security-auditor: audit the codebase for security vulnerabilities
```

**감사 보고서:**
```
Security Audit Report
Generated: 2026-02-09

CRITICAL (2)
├─ [SQL-001] SQL injection in user search endpoint
│  File: src/api/users.js:45
│  Fix: Use parameterized queries
│
└─ [AUTH-002] JWT secret hardcoded in source
   File: src/config/auth.js:12
   Fix: Move to environment variable

HIGH (3)
├─ [XSS-001] Unescaped user input in profile page
├─ [CSRF-001] Missing CSRF tokens on forms
└─ [SEC-001] Sensitive data logged to console

MEDIUM (5)
└─ ...

Automated fixes applied: 7/10
Manual review required: 3/10
```

### Data Science 에이전트 (3개)

데이터 분석과 머신러닝을 담당합니다.

#### 1. data-scientist

데이터 분석 및 모델링을 수행합니다.

**전문 분야:**
- 데이터 분석
- 통계 분석
- 예측 모델링
- 데이터 시각화

**사용 예시:**
```bash
> data-scientist: analyze user behavior and predict churn
```

**분석 코드:**
```python
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
import matplotlib.pyplot as plt

# Load and prepare data
df = pd.read_csv('user_activity.csv')
features = ['login_frequency', 'session_duration', 'feature_usage']
X = df[features]
y = df['churned']

# Train model
model = RandomForestClassifier(n_estimators=100)
model.fit(X_train, y_train)

# Feature importance
importance = pd.DataFrame({
    'feature': features,
    'importance': model.feature_importances_
}).sort_values('importance', ascending=False)

print("Churn Prediction Model")
print(f"Accuracy: {model.score(X_test, y_test):.2%}")
print("\nTop Churn Indicators:")
print(importance)
```

#### 2. ml-engineer

머신러닝 파이프라인을 구축합니다.

**전문 분야:**
- ML 파이프라인 설계
- 모델 학습 및 튜닝
- 모델 배포
- MLOps

**사용 예시:**
```bash
> ml-engineer: build ML pipeline for product recommendations
```

#### 3. stats-analyzer

통계 분석을 전문으로 합니다.

**전문 분야:**
- 가설 검정
- A/B 테스트 분석
- 회귀 분석
- 시계열 분석

**사용 예시:**
```bash
> stats-analyzer: analyze A/B test results for new checkout flow
```

### DevOps 에이전트 (2개)

인프라와 배포를 관리합니다.

#### 1. devops-engineer

전반적인 DevOps 작업을 수행합니다.

**전문 분야:**
- 인프라 코드 (Terraform, CloudFormation)
- 컨테이너화 (Docker, Kubernetes)
- 모니터링 설정
- 로그 관리

**사용 예시:**
```bash
> devops-engineer: set up Kubernetes deployment with auto-scaling
```

**생성된 매니페스트:**
```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
      - name: app
        image: myapp:latest
        ports:
        - containerPort: 3000
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: web-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: web-app
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
```

#### 2. ci-cd-specialist

CI/CD 파이프라인을 구축합니다.

**전문 분야:**
- GitHub Actions
- GitLab CI
- Jenkins 파이프라인
- 배포 자동화

**사용 예시:**
```bash
> ci-cd-specialist: create GitHub Actions workflow for automated testing and deployment
```

**워크플로우:**
```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run tests
        run: |
          npm install
          npm test
          npm run test:e2e

      - name: Upload coverage
        uses: codecov/codecov-action@v3

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker image
        run: docker build -t myapp:${{ github.sha }} .

      - name: Push to registry
        run: docker push myapp:${{ github.sha }}

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Deploy to production
        run: |
          kubectl set image deployment/web-app \
            app=myapp:${{ github.sha }}
          kubectl rollout status deployment/web-app
```

## 스마트 모델 라우팅

OMC는 작업의 복잡도를 자동으로 분석하여 최적의 Claude 모델을 선택합니다.

### 라우팅 전략

```
작업 분석
    ↓
┌─────────────────────┐
│ Complexity Analyzer │
└─────────┬───────────┘
          ↓
    [복잡도 점수]
          ↓
    ┌─────┴─────┐
    │           │
Simple (0-30)  Complex (70-100)
    ↓           ↓
  Haiku        Opus
  (빠름)      (강력함)
    │           │
    └─────┬─────┘
          ↓
      작업 실행
```

### 모델 선택 기준

#### Haiku 사용 (간단한 작업)

**특징:**
- 빠른 응답 속도 (1-2초)
- 낮은 비용 (Opus의 1/10)
- 높은 처리량

**적합한 작업:**
```bash
# 간단한 코드 생성
> autopilot: add a new API endpoint for user profile

# 단순 리팩토링
> eco: rename variable userName to user_name throughout the file

# 기본 테스트 작성
> autopilot: write unit tests for the sum function

# 간단한 버그 수정
> autopilot: fix typo in error message
```

#### Opus 사용 (복잡한 작업)

**특징:**
- 강력한 추론 능력
- 긴 컨텍스트 이해
- 복잡한 문제 해결

**적합한 작업:**
```bash
# 아키텍처 설계
> arch: design a distributed caching system with Redis cluster

# 복잡한 알고리즘
> autopilot: implement a real-time collaborative editing algorithm (OT or CRDT)

# 전체 시스템 리팩토링
> ralph: refactor the entire codebase to hexagonal architecture

# 복잡한 디버깅
> autopilot: debug the race condition causing intermittent failures
```

### 비용 절감 효과

**실제 프로젝트 예시:**

```
전체 작업: API 서버 개발 (100개 작업)

모든 작업을 Opus로 처리:
├─ 100개 작업 × $0.30 = $30
└─ 예상 시간: 2시간

스마트 라우팅 사용:
├─ 70개 단순 작업 × $0.03 (Haiku) = $2.10
├─ 30개 복잡 작업 × $0.30 (Opus) = $9.00
├─ 총 비용: $11.10
└─ 예상 시간: 1.5시간

절감:
├─ 비용: 63% 절감 ($18.90 절약)
└─ 시간: 25% 단축
```

### 수동 모델 선택

필요시 모델을 명시적으로 선택할 수 있습니다:

```bash
# Haiku 강제 사용 (빠르고 저렴하게)
> eco: implement basic CRUD operations
# 내부적으로 Haiku 사용

# Opus 강제 사용 (품질 우선)
> ralph: implement critical security feature
# 내부적으로 Opus 사용
```

## HUD Statusline

실시간으로 작업 진행 상황을 시각화하는 상태 표시줄입니다.

### 표시 정보

#### 1. 오케스트레이션 메트릭

```
┌─────────────────────────────────────────┐
│ OMC Orchestration Status                │
├─────────────────────────────────────────┤
│ Mode: Ultrapilot                        │
│ Active Agents: 4/32                     │
│ Pending Tasks: 12                       │
│ Completed: 8                            │
│ Success Rate: 95.2%                     │
└─────────────────────────────────────────┘
```

#### 2. 활성 에이전트 표시

각 에이전트의 실시간 상태를 표시합니다:

```
Active Agents:
┌─────────────────────────────────────────┐
│ [1] Frontend      ████████████░░  75%   │
│     Status: Implementing component      │
│     ETA: 2m 15s                         │
├─────────────────────────────────────────┤
│ [2] Backend       ██████████████░  85%  │
│     Status: Writing API tests           │
│     ETA: 1m 30s                         │
├─────────────────────────────────────────┤
│ [3] Database      ██████░░░░░░░░  45%   │
│     Status: Creating migration          │
│     ETA: 4m 05s                         │
├─────────────────────────────────────────┤
│ [4] Testing       ████░░░░░░░░░░  30%   │
│     Status: Running E2E tests           │
│     ETA: 5m 45s                         │
└─────────────────────────────────────────┘
```

#### 3. 토큰 사용량 추적

실시간 토큰 소비를 모니터링합니다:

```
Token Usage:
┌─────────────────────────────────────────┐
│ Session Total: 45,230 tokens            │
│ ├─ Input:  23,450 tokens                │
│ └─ Output: 21,780 tokens                │
│                                         │
│ By Model:                               │
│ ├─ Haiku: 35,200 tokens ($1.05)        │
│ └─ Opus:  10,030 tokens ($3.01)        │
│                                         │
│ Session Cost: $4.06                     │
│ Estimated Project Total: $18.50         │
└─────────────────────────────────────────┘
```

#### 4. 진행 표시기

전체 프로젝트 진행률을 표시합니다:

```
Overall Progress:
┌─────────────────────────────────────────┐
│ Project: E-commerce Platform            │
│                                         │
│ ████████████████████░░░░░░░░  62%      │
│                                         │
│ Phase 1: Setup        [✓] Complete      │
│ Phase 2: Backend      [▶] In Progress   │
│ Phase 3: Frontend     [ ] Pending       │
│ Phase 4: Integration  [ ] Pending       │
│ Phase 5: Testing      [ ] Pending       │
│                                         │
│ Est. Completion: 2h 15m                 │
└─────────────────────────────────────────┘
```

### HUD 설정

상태 표시줄을 커스터마이즈할 수 있습니다:

```json
// .omc/config.json
{
  "hud": {
    "enabled": true,
    "position": "bottom",
    "showTokens": true,
    "showCost": true,
    "showETA": true,
    "refreshInterval": 1000,
    "theme": {
      "progressBar": "█",
      "progressEmpty": "░",
      "colors": {
        "success": "green",
        "warning": "yellow",
        "error": "red"
      }
    }
  }
}
```

## 스킬 학습 시스템

OMC는 작업 패턴을 학습하여 재사용 가능한 스킬로 저장합니다.

### 패턴 추출

세션에서 성공적인 워크플로우를 자동으로 감지합니다:

```bash
# 사용자가 실행한 작업
> autopilot: create React component with TypeScript, tests, and Storybook story
```

OMC가 학습한 패턴:

```yaml
# .omc/skills/react-component-full.yaml
name: React Component Full Stack
description: Create complete React component with all best practices
pattern:
  - Create TypeScript component file
  - Add PropTypes and interfaces
  - Write unit tests (Jest + RTL)
  - Create Storybook story
  - Add CSS module
  - Export from index

triggers:
  - "create react component"
  - "new component"
  - "add component"

template: |
  1. Component: src/components/{name}/{name}.tsx
  2. Types: src/components/{name}/{name}.types.ts
  3. Tests: src/components/{name}/{name}.test.tsx
  4. Story: src/components/{name}/{name}.stories.tsx
  5. Styles: src/components/{name}/{name}.module.css
  6. Index: src/components/{name}/index.ts

usage_count: 15
success_rate: 94%
avg_completion_time: "3m 45s"
```

### 재사용 가능한 워크플로우

학습된 스킬을 재사용합니다:

```bash
# 스킬 적용
> autopilot: use "React Component Full Stack" skill to create Button component
```

OMC가 자동으로:
1. 학습된 패턴 로드
2. 컴포넌트 이름으로 템플릿 커스터마이즈
3. 모든 파일 생성
4. 이전 성공 사례 기반으로 최적화

**생성 결과:**
```
Created:
├─ src/components/Button/
│  ├─ Button.tsx
│  ├─ Button.types.ts
│  ├─ Button.test.tsx
│  ├─ Button.stories.tsx
│  ├─ Button.module.css
│  └─ index.ts
└─ Completed in 2m 12s (43% faster than average)
```

### 자동 생성 스킬

반복되는 패턴을 감지하면 자동으로 스킬을 제안합니다:

```
OMC Skill Suggestion:
┌─────────────────────────────────────────┐
│ Pattern Detected!                       │
├─────────────────────────────────────────┤
│ You've created 3 API endpoints with     │
│ similar structure:                      │
│ - GET endpoint                          │
│ - Request validation                    │
│ - Error handling                        │
│ - Unit tests                            │
│                                         │
│ Would you like to save this as a skill?│
│                                         │
│ Suggested name: "REST Endpoint Full"   │
│                                         │
│ [Y] Yes  [N] No  [C] Customize          │
└─────────────────────────────────────────┘
```

### 스킬 관리

스킬을 조회하고 관리합니다:

```bash
# 모든 스킬 보기
> omc-cli skills list

Available Skills:
1. React Component Full Stack (15 uses, 94% success)
2. REST Endpoint Full (8 uses, 100% success)
3. Database Migration (5 uses, 80% success)
4. E2E Test Suite (12 uses, 91% success)

# 특정 스킬 상세 정보
> omc-cli skills show "React Component Full Stack"

# 스킬 수정
> omc-cli skills edit "React Component Full Stack"

# 스킬 삭제
> omc-cli skills delete "Database Migration"
```

## 분석 및 비용 추적

프로젝트의 모든 메트릭을 추적하고 분석합니다.

### 토큰 사용량 분석

모드별 토큰 소비를 추적합니다:

```bash
> omc-analytics tokens
```

**출력:**

```
Token Usage Report (Last 7 days)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

By Mode:
┌──────────────┬────────────┬────────────┬──────────┐
│ Mode         │ Input      │ Output     │ Total    │
├──────────────┼────────────┼────────────┼──────────┤
│ Autopilot    │ 145,230    │ 98,450     │ 243,680  │
│ Ultrawork    │ 89,340     │ 67,890     │ 157,230  │
│ Ralph        │ 234,560    │ 189,340    │ 423,900  │
│ Ultrapilot   │ 178,900    │ 145,670    │ 324,570  │
│ Ecomode      │ 67,890     │ 45,230     │ 113,120  │
│ Plan         │ 34,560     │ 28,340     │ 62,900   │
│ List         │ 12,340     │ 8,900      │ 21,240   │
├──────────────┼────────────┼────────────┼──────────┤
│ Total        │ 762,820    │ 583,820    │1,346,640 │
└──────────────┴────────────┴────────────┴──────────┘

By Model:
┌──────────┬────────────┬───────────┬──────────┐
│ Model    │ Tokens     │ % of Total│ Cost     │
├──────────┼────────────┼───────────┼──────────┤
│ Haiku    │ 945,230    │ 70.2%     │ $28.36   │
│ Opus     │ 401,410    │ 29.8%     │ $120.42  │
├──────────┼────────────┼───────────┼──────────┤
│ Total    │ 1,346,640  │ 100%      │ $148.78  │
└──────────┴────────────┴───────────┴──────────┘

Smart Routing Savings: $67.24 (31.1%)
```

### 세션별 비용

각 세션의 비용을 추적합니다:

```bash
> omc-analytics sessions
```

**출력:**

```
Recent Sessions
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌────────┬──────────────────────┬──────────┬─────────┬─────────┐
│ ID     │ Description          │ Duration │ Tokens  │ Cost    │
├────────┼──────────────────────┼──────────┼─────────┼─────────┤
│ #142   │ Implement user auth  │ 45m 23s  │ 89,340  │ $12.45  │
│ #141   │ Add payment flow     │ 1h 12m   │ 145,670 │ $28.90  │
│ #140   │ Refactor backend     │ 2h 05m   │ 234,560 │ $45.67  │
│ #139   │ Fix responsive bugs  │ 23m 12s  │ 34,560  │ $5.23   │
│ #138   │ E2E test suite       │ 38m 45s  │ 67,890  │ $9.87   │
└────────┴──────────────────────┴──────────┴─────────┴─────────┘

Average cost per session: $20.42
Most expensive mode: Ralph ($45.67 avg)
Most efficient mode: Ecomode ($8.34 avg)
```

### 성능 메트릭

작업 성능을 분석합니다:

```bash
> omc-analytics performance
```

**출력:**

```
Performance Metrics
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Completion Times:
┌───────────────────────┬─────────┬─────────┬─────────┐
│ Task Type             │ Average │ Fastest │ Slowest │
├───────────────────────┼─────────┼─────────┼─────────┤
│ Component Creation    │ 3m 45s  │ 1m 23s  │ 8m 12s  │
│ API Endpoint          │ 5m 12s  │ 2m 45s  │ 12m 34s │
│ Database Migration    │ 2m 30s  │ 1m 05s  │ 5m 45s  │
│ Test Suite            │ 7m 23s  │ 3m 12s  │ 15m 45s │
│ Refactoring          │ 12m 45s │ 5m 34s  │ 28m 12s │
└───────────────────────┴─────────┴─────────┴─────────┘

Success Rates:
┌───────────────────┬──────────┬───────────┬─────────┐
│ Agent             │ Tasks    │ Success   │ Rate    │
├───────────────────┼──────────┼───────────┼─────────┤
│ Architect         │ 23       │ 22        │ 95.7%   │
│ Frontend          │ 45       │ 44        │ 97.8%   │
│ Backend           │ 38       │ 36        │ 94.7%   │
│ Testing           │ 67       │ 65        │ 97.0%   │
│ DevOps            │ 12       │ 11        │ 91.7%   │
└───────────────────┴──────────┴───────────┴─────────┘

Parallelization Efficiency:
├─ Average parallel agents: 3.2
├─ Max parallel agents used: 8
├─ Speed improvement: 3.5x vs sequential
└─ Idle time: 8.2% (very efficient)
```

### 비용 예측

프로젝트 비용을 예측합니다:

```bash
> omc-analytics estimate "build e-commerce platform"
```

**출력:**

```
Cost Estimation
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Project: E-commerce Platform
Estimated Complexity: High

Breakdown:
┌────────────────────────┬───────────┬─────────┐
│ Component              │ Est. Time │ Est. Cost│
├────────────────────────┼───────────┼─────────┤
│ Architecture Design    │ 1-2 hours │ $15-25  │
│ Backend API            │ 3-4 hours │ $45-70  │
│ Frontend UI            │ 4-5 hours │ $50-80  │
│ Authentication         │ 1-2 hours │ $20-35  │
│ Payment Integration    │ 2-3 hours │ $30-50  │
│ Testing Suite          │ 2-3 hours │ $25-45  │
│ DevOps Setup           │ 1-2 hours │ $15-30  │
├────────────────────────┼───────────┼─────────┤
│ Total                  │ 14-21 hrs │$200-335 │
└────────────────────────┴───────────┴─────────┘

With Ecomode: $140-235 (30% savings)
With Smart Routing: $180-285 (15% savings)

Recommended Approach:
1. Use 'arch' for initial design ($15-25)
2. Use 'ultrapilot' for parallel development ($150-240)
3. Use 'ultraqa' for comprehensive testing ($25-45)
4. Use 'eco' where appropriate to reduce costs

Estimated Project Duration: 2-3 days
```

### 비용 알림 설정

예산 제한을 설정할 수 있습니다:

```bash
> omc-cli config set budget.daily 50
> omc-cli config set budget.weekly 200
> omc-cli config set budget.alerts true
```

예산 초과 시 알림:

```
┌─────────────────────────────────────────┐
│ Budget Alert!                           │
├─────────────────────────────────────────┤
│ Daily budget: $50.00                    │
│ Current usage: $47.23 (94.5%)           │
│                                         │
│ Estimated cost of this task: $8.50     │
│ This will exceed your daily budget.    │
│                                         │
│ Continue anyway? [Y/n]                  │
└─────────────────────────────────────────┘
```

## 다음 단계

핵심 기능을 이해했다면, 이제 고급 활용법을 알아보겠습니다:

- **[챕터 5: 고급 활용 및 유틸리티](/oh-my-claudecode-guide-05-advanced/)** - Rate Limit Wait, Multi-AI Orchestration, 베스트 프랙티스

## 참고 자료

- GitHub 저장소: [https://github.com/Yeachan-Heo/oh-my-claudecode](https://github.com/Yeachan-Heo/oh-my-claudecode)
- Claude Code 문서: [https://docs.anthropic.com/claude/docs/claude-code](https://docs.anthropic.com/claude/docs/claude-code)
- 이슈 트래커: [https://github.com/Yeachan-Heo/oh-my-claudecode/issues](https://github.com/Yeachan-Heo/oh-my-claudecode/issues)
