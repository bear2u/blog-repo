# Claude Code 2.0 가이드 및 코딩 에이전트 활용법

> 원문: [A Guide to Claude Code 2.0 and getting better at using coding agents](https://sankalp.bearblog.dev/my-experience-with-claude-code-20-and-how-to-get-better-at-using-coding-agents/)
> 저자: Sankalp
> 작성일: 2025년 12월 27일
> 번역: Claude

---

## 목차

1. [서론 및 배경](#1장-서론-및-배경)
2. [저자의 여정](#2장-저자의-여정)
3. [비기술 사용자를 위한 기술 설명](#3장-비기술-사용자를-위한-기술-설명)
4. [Claude Code 2.0의 삶의 질 개선 기능](#4장-claude-code-20의-삶의-질-개선-기능)
5. [명령어 및 커스터마이징](#5장-명령어-및-커스터마이징)
6. [서브 에이전트](#6장-서브-에이전트-sub-agents)
7. [Task 도구](#7장-task-도구)
8. [컨텍스트 엔지니어링 심층 분석](#8장-컨텍스트-엔지니어링-심층-분석)
9. [스킬 및 플러그인](#9장-스킬-및-플러그인)
10. [훅](#10장-훅-hooks)
11. [MCP 서버 및 코드 실행](#11장-mcp-서버-및-코드-실행)
12. [저자의 개인 워크플로우](#12장-저자의-개인-워크플로우)
13. [Opus 4.5가 뛰어난 이유](#13장-opus-45가-뛰어난-이유)
14. [시스템 리마인더](#14장-시스템-리마인더)
15. [컨텍스트 관리 전략](#15장-컨텍스트-관리-전략)
16. [다른 도구와의 비교](#16장-다른-도구와의-비교)
17. [커뮤니티 리소스](#17장-커뮤니티-리소스)
18. [핵심 요약](#18장-핵심-요약)

---

## 1장: 서론 및 배경

이 글은 2025년 7월에 작성했던 Claude Code 글의 후속편입니다. 버전 2.0의 새로운 기능들과 Opus 4.5 출시 이후 개선된 점들을 다룹니다. 기술적인 독자와 비기술적("기술-라이트") 독자 모두를 위해 AI 코딩 에이전트를 효과적으로 사용하는 방법을 설명합니다.

### 이 글이 중요한 이유

- **심층적인 Claude Code 자료에 대한 수요 충족**
- **Claude Code 학습이 Codex, OpenCode, Cursor 같은 다른 도구로 전이됨**
- **AI를 "따라잡기"가 아닌 "증강"의 관점으로 접근**
- **세 가지 핵심 요소:** 도구 최신화, 도메인 지식 향상, 열린 실험 마인드

---

## 2장: 저자의 여정

저자는 Anthropic 도구와의 관계를 다음과 같이 설명합니다:

| 기간 | 상태 |
|------|------|
| 2025년 6-9월 | Claude Code 선호 |
| 중간 기간 | Sonnet 4/Opus 4 품질 우려로 Codex/GPT-5로 전환 |
| 2025년 11월 | Opus 4.5 출시 후 Claude로 복귀 |
| 현재 | Opus 4.5를 메인으로, GPT-5.2-Codex는 코드 리뷰용 |

---

## 3장: 비기술 사용자를 위한 기술 설명

### 컨텍스트 윈도우 (Context Window)

> "대화 중 LLM이 한 번에 보고 처리할 수 있는 최대 토큰 양"

쉽게 말해, AI가 한 번에 기억하고 처리할 수 있는 정보의 양입니다.

### 도구 호출 (Tool Calling)

> 엔지니어가 정의한 함수로, LLM이 특정 작업을 수행할 수 있게 함

AI가 파일을 읽거나, 검색하거나, 코드를 실행하는 등의 실제 작업을 할 수 있게 해주는 기능입니다.

### 에이전트 (Agent)

> "LLM이 자체 프로세스와 도구 사용을 동적으로 지시하는 시스템"

단순히 질문에 답하는 것이 아니라, 스스로 판단하고 도구를 사용해 작업을 수행하는 AI 시스템입니다.

### 에이전틱 (Agentic)

> 도구 호출 기능과 능동적 행동을 의미

AI가 수동적이 아닌 능동적으로 행동하는 특성을 말합니다.

---

## 4장: Claude Code 2.0의 삶의 질 개선 기능

Claude Code 2.0에서 추가된 주요 기능들입니다:

### 주요 기능 목록

1. **diff에서 구문 강조** (버전 2.0.71)
   - 코드 변경사항을 더 쉽게 파악할 수 있음

2. **생각하는 동안 팁 표시**
   - AI가 생각하는 동안 유용한 팁을 보여줌

3. **비침입적 피드백 UI**
   - 작업 흐름을 방해하지 않는 피드백 인터페이스

4. **Ultrathink 모드**
   - 복잡한 문제에 대한 엄격한 분석 모드

5. **`/context` 명령어**
   - 현재 컨텍스트 사용량 확인

6. **체크포인팅**
   - `Esc + Esc` 또는 `/rewind`로 이전 상태로 되돌리기

7. **프롬프트 제안** (버전 2.0.73)
   - AI가 다음 프롬프트를 제안

8. **프롬프트 히스토리 검색**
   - `Ctrl + R`로 이전 프롬프트 검색

9. **LSP 지원**
   - 플러그인을 통한 언어 서버 프로토콜 지원

---

## 5장: 명령어 및 커스터마이징

### 내장 슬래시 명령어

Claude Code에는 일반적인 작업을 위한 다양한 내장 명령어가 있습니다.

### 커스텀 명령어 만들기

- **프로젝트 수준** 또는 **전역 수준**에서 생성 가능
- 커스텀 명령어는 컨텍스트에 추가되는 **정적 프롬프트**

### 예시: `/handoff` 명령어

저자가 만든 세션 전환용 명령어입니다. 한 세션에서 다른 세션으로 작업을 넘길 때 유용합니다.

```
# 커스텀 명령어 구조
- 명령어 이름
- 설명
- 실행할 프롬프트
```

---

## 6장: 서브 에이전트 (Sub-Agents)

서브 에이전트는 메인 에이전트가 생성하는 **별도의 Claude 인스턴스**입니다.

### 주요 유형

| 유형 | 설명 | 특징 |
|------|------|------|
| **Explore** | 읽기 전용 코드베이스 검색 전문가 | 기본적으로 Haiku 사용, 새 컨텍스트로 시작 |
| **General-purpose** | 전체 도구 접근 가능 | 컨텍스트 상속 |
| **Plan** | 구현 계획을 위한 소프트웨어 아키텍트 | 컨텍스트 상속 |
| **claude-code-guide** | 문서 조회 전문 | - |
| **statusline-setup** | 설정 에이전트 | - |

### 중요한 차이점

```
Explore 에이전트
├── 새로운 컨텍스트로 시작
├── 독립적 검색에 효율적
└── 메인 대화와 분리

General-purpose / Plan 에이전트
├── 전체 대화 컨텍스트 상속
├── 이전 맥락 파악 가능
└── 연속적인 작업에 적합
```

---

## 7장: Task 도구

서브 에이전트 생성을 제어하는 도구입니다.

### 파라미터

| 파라미터 | 설명 | 필수 여부 |
|----------|------|-----------|
| Description | 3-5 단어의 간단한 설명 | 필수 |
| Prompt | 상세한 작업 내용 | 필수 |
| Subagent type | 에이전트 유형 | 필수 |
| Model selection | Sonnet, Opus, Haiku | 선택 |
| Background execution | 백그라운드 실행 여부 | 선택 |
| Resume capability | 이전 작업 계속하기 | 선택 |

### 활용 팁

- 간단한 검색은 **Explore** 에이전트
- 복잡한 작업은 **General-purpose** 에이전트
- 계획 수립은 **Plan** 에이전트

---

## 8장: 컨텍스트 엔지니어링 심층 분석

### 핵심 개념

컨텍스트 엔지니어링은 다음 질문에 답합니다:

> "어떤 컨텍스트 구성이 원하는 모델 행동을 생성할 가능성이 가장 높은가?"

### 주요 활동

- 관련 컨텍스트 연결
- 비관련 정보 감소
- 지시 단순화
- 도구 호출 정확도 향상

### 컨텍스트 열화 (Context Degradation)

```
문제점:
├── 컨텍스트가 길어지면 성능 저하 (context rot)
├── 효과적인 컨텍스트 윈도우 = 명시된 용량의 50-60%
└── 어텐션 메커니즘은 먼 관계에서 어려움
```

### 최적화 기법

1. **시스템 리마인더** - 런타임에 주입
2. **Todo 리스트/계획** - 압축 중에도 유지
3. **마크다운 기반 상태 보존**
4. **전략적 도구 결과 요약**

---

## 9장: 스킬 및 플러그인

### 스킬 (Skills)

`SKILL.md` 파일이 있는 폴더에 번들된 **도메인 전문 지식**입니다.

**특징:**
- 관련성이 있을 때 **온디맨드로 로드**
- **500줄 미만** 유지 권장 (파일 분할 가능)
- 정적 지시로 시스템 프롬프트 부풀리기 방지

### 플러그인 (Plugins)

배포 가능한 패키지로 다음을 번들합니다:

```
플러그인 구성요소
├── 스킬
├── 슬래시 명령어
├── 서브 에이전트
├── 훅
└── MCP 서버
```

**예시:** `frontend-design` 플러그인
- 미적 선택 가이드
- 일반적인 AI 미학 회피 지침

---

## 10장: 훅 (Hooks)

에이전트 루프 생명주기 단계에서 실행되는 **이벤트 기반 스크립트**입니다.

### 훅 유형

| 훅 | 실행 시점 | 용도 |
|----|----------|------|
| **Stop** | Claude가 응답 완료 후 | 후처리 작업 |
| **UserPromptSubmit** | Claude가 입력 처리 전 | 전처리, 검증 |

### 창의적 활용 사례

- **알림 시스템** - 작업 완료 시 알림
- **지속적 작업 프롬프트** - 자동 후속 작업
- **모니터링** - 작업 상태 추적

### 구현 방법

bash 스크립트로 자동화 가능합니다.

---

## 11장: MCP 서버 및 코드 실행

### MCP (Model Context Protocol)란?

서버에서 **도구, 리소스, 프롬프트**를 노출하는 프로토콜입니다.

### 특징

- 도구 정의가 **미리 로드됨**
- 컨텍스트 부풀림 우려 존재
- MCP 패턴의 코드 실행: 도구 정의 대신 **API 노출**

### 비용 고려사항

```
⚠️ 주의
여러 MCP 서버 사용 시:
├── 컨텍스트 소비 증가
└── 지연 시간 증가
```

---

## 12장: 저자의 개인 워크플로우

### 도구 설정

| 도구 | 용도 |
|------|------|
| Claude Code | 메인 드라이버 |
| Codex (GPT-5.2) | 코드 리뷰 및 어려운 작업 |
| Cursor | 코드 읽기 및 수동 편집 |

> 💡 저자는 Plan Mode를 거의 사용하지 않습니다.

### 탐색 단계

1. **광범위한 명확화 질문**
2. **`/ultrathink`** 사용 - 엄격한 분석
3. **ASCII 다이어그램** 생성 - 이해도 향상
4. **"버릴 첫 번째 초안"** 접근법 활용

### 실행 단계

1. 변경사항 **면밀히 모니터링** (마이크로 매니지)
2. 정신 모델에 대해 **Claude의 이해도 테스트**
3. 첫 번째 패스 인사이트 기반으로 **프롬프트 개선**
4. **더 날카로운 프롬프트**로 반복

### 리뷰 단계

- **GPT-5.2-Codex**가 버그 탐지에 우수
- `/review` 명령어 사용
- 심각도 레벨 보고 (P1, P2)
- 대안들보다 **오탐 적음**

---

## 13장: Opus 4.5가 뛰어난 이유

GPT-5.2-Codex가 약간의 기능 우위가 있음에도 불구하고, Opus 4.5를 선택하는 이유:

### 장점

| 항목 | 설명 |
|------|------|
| **토큰 처리량** | 더 빠른 피드백 루프 가능 |
| **커뮤니케이션** | 우수한 커뮤니케이터이자 페어 프로그래머 |
| **의도 감지** | 사용자 의도를 더 정확히 파악 |
| **설명 능력** | 뛰어난 설명 제공 |
| **대화 톤** | 더 자연스러운 대화 |
| **개성** | "영혼"이 있는 것처럼 느껴짐 |

### 저자의 평가

> "Opus 4.5는 단순한 도구가 아니라 진정한 페어 프로그래밍 파트너입니다."

---

## 14장: 시스템 리마인더

### 정의

런타임에 주입되는 리마인더로 다음 위치에 나타납니다:

- 사용자 메시지 컨텍스트
- 도구 결과 컨텍스트
- 에이전트 지시 참조

### 목적

**"중간에서 길을 잃는" 어텐션 문제 해결**

### 활용 예시

```
목표(todo 리스트, 계획)를 반복적으로 언급
→ 최근 어텐션 범위에 유지
→ 목표 불일치 방지
```

---

## 15장: 컨텍스트 관리 전략

### Todo 리스트 패턴

작업 목록을 **지속적으로 다시 작성**하면:

1. 목표를 모델의 최근 컨텍스트 윈도우로 밀어넣음
2. 어텐션을 조작
3. 긴 대화에서 목표 불일치 방지

### 압축 (Compaction)

```
언제 사용?
└── 컨텍스트가 ~60% 용량에 도달했을 때

방법:
├── `/compact` 명령어 (CC 2.0에서 더 빠름)
└── 새 대화 전 Claude에게 세션 요약 요청
```

### 체크포인팅

| 기능 | 설명 |
|------|------|
| 되돌리기 | 이전 대화 지점으로 복귀 |
| 실행 취소 | 코드와 대화 히스토리 되돌림 |
| 반복 개발 | 시행착오를 통한 개발에 필수 |

---

## 16장: 다른 도구와의 비교

### Claude Code vs Codex

| 항목 | Claude Code | Codex |
|------|-------------|-------|
| **커뮤니케이션** | 더 나음 | 더 간결 |
| **UX 완성도** | 높음 | 덜 침입적 |
| **피드백 루프** | 더 빠름 | - |
| **구독 비용** | - | 더 저렴 |
| **UI 대비** | 높은 대비 | 낮은 대비 |
| **폰트** | 굵음, 가독성 좋음 | 얇음, 읽기 어려움 |

### 코드 리뷰 비교

**GPT-5.2-Codex가 우수한 항목:**

- 버그 찾기 정확도
- 심각도 분류
- 낮은 오탐률

---

## 17장: 커뮤니티 리소스

### 유용한 자료

| 자료 | 설명 |
|------|------|
| **awesome-claude-code** | 명령어, 훅, 스킬 모음 저장소 |
| **리버스 엔지니어링된 시스템 프롬프트** | Claude의 내부 동작 이해 |
| **Reddit 토론** | 고급 커스터마이징 팁 |
| **Twitter 담론** | 에이전트 사용 패턴 공유 |

---

## 18장: 핵심 요약

### 7가지 핵심 교훈

1. **도구 숙련도 전이**
   - Claude Code 메커니즘 학습이 여러 에이전트 플랫폼에 적용됨

2. **컨텍스트가 핵심**
   - 컨텍스트 엔지니어링 이해가 에이전트 효과를 근본적으로 향상

3. **증강 마인드셋**
   - "따라잡기"보다 기존 스킬을 증폭하는 도구 사용에 집중

4. **실험이 중요**
   - 기능을 정기적으로 시도; 실습을 통해 직관 개발

5. **커스터마이징 파워**
   - 스킬, 훅, 명령어로 정교한 개인화 워크플로우 가능

6. **모델 선택**
   - 다른 모델이 다른 작업에 뛰어남 (Opus는 생성, GPT는 리뷰)

7. **빠른 피드백 루프**
   - 처리량이 지속적인 생산성에 원시 능력만큼 중요

---

## 저자의 명언

> "구현이 이제 훨씬 빨라졌으니, 취향 다듬기에 더 많은 시간을 쓸 수 있습니다"

저자는 세 가지를 강조합니다:
- **도구 최신화 유지**
- **도메인 업스킬**
- **실험을 통한 열린 마음 유지**

---

## 마치며

글은 2026년에 능력 돌파구가 있을 가능성이 높지만, 독자들에게 다음과 같이 촉구하며 이것이 **"변혁적인 시대"**라고 결론짓습니다:

> **"오늘 이 글에서 새로운 기능 하나를 시도해보세요."**

---

*이 문서는 원문을 한국어로 번역 및 정리한 것입니다.*
